/*$file${include::qassert.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: qpc.qm
* File:  ${include::qassert.h}
*
* This code has been generated by QM 5.2.5 <www.state-machine.com/qm>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This code is covered by the following QP license:
* License #    : LicenseRef-QL-dual
* Issued to    : Any user of the QP/C real-time embedded framework
* Framework(s) : qpc
* Support ends : 2023-12-31
* License scope:
*
* Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
*
* SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
*
* This software is dual-licensed under the terms of the open source GNU
* General Public License version 3 (or any later version), or alternatively,
* under the terms of one of the closed source Quantum Leaps commercial
* licenses.
*
* The terms of the open source GNU General Public License version 3
* can be found at: <www.gnu.org/licenses/gpl-3.0>
*
* The terms of the closed source Quantum Leaps commercial licenses
* can be found at: <www.state-machine.com/licensing>
*
* Redistributions in source code must retain this top-level comment block.
* Plagiarizing this software to sidestep the license obligations is illegal.
*
* Contact information:
* <www.state-machine.com/licensing>
* <info@state-machine.com>
*/
/*$endhead${include::qassert.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*! @file
* @brief QP Functional Safety (FuSa) Subsystem.
*
* @description
* This header file is part of the @ref ssp_fusa and contains
* the following facilities:
* - Software assertions (Failure Assertion Programming (FAP) in IEC 61508)
* - Software Self-Monitoring (SSM) techniques:
*   + Handling of Duplicate Inverse Storage
*   + Handling of Memory Markers
*
* @note
* This header file can be used in C, C++, and mixed C/C++ programs.
*
* @attention
* The preprocessor switch #Q_UNSAFE disables the QP Functional Safety
* System. However, it is generally **NOT RECOMMENDED**, especially
* in the production code. Instead, the failure callback Q_onAssert()
* should be very carefully designed, implemented, and tested in various
* failure modes.
*/
#ifndef QASSERT_H_
#define QASSERT_H_

#ifdef __cplusplus
    extern "C" {
#endif

#ifndef Q_UNSAFE
/*$declare${QP-FuSa::enabled} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${QP-FuSa::enabled::Q_DEFINE_THIS_MODULE} ................................*/
/*! Define the user-specified module name for assertions in this file.
*
* @details
* Macro to be placed at the top of each C/C++ module to define the
* single instance of the module name string to be used in reporting
* assertions in this module. This macro takes the user-supplied parameter
* `name_` instead of `__FILE__` to precisely control the name of the
* module.
*
* @param[in] name_ string constant representing the module name
*
* @note
* This macro should **not** be terminated by a semicolon.
*
* @trace
* - @tr{DVP-QP-PCLP-823}
*/
#define Q_DEFINE_THIS_MODULE(name_) \
    static char const Q_this_module_[] = name_;

/*${QP-FuSa::enabled::Q_ASSERT_NOCRIT_} ....................................*/
/*! General-purpose assertion with user-specified ID number
* and no critical section
*
* @param[in] id_   ID number (unique within the module) of the assertion
* @param[in] expr_ Boolean expression to check
*
* @attention
* This macro must be called inside already established critical section.
* The evaluation of the expression `expr_` as well as calling of
* Q_onAssert() happens inside that critical section.
*
* @attention
* The assertion expression (`expr_`) must be possibly simple, have
* __no side effects__, and quick to evaluate because the evaluation
* happens inside a critical section. Also, the expression must __NOT__
* call any functions that might use critical sections inside (because
* this would cause nesting of critical sections, which might not be
* supported).
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ASSERT_NOCRIT_(id_, expr_)  \
    ((expr_) ? ((void)0) : Q_onAssert(&Q_this_module_[0], (id_)))

/*${QP-FuSa::enabled::Q_ERROR_NOCRIT_} .....................................*/
/*! Assertion with user-specified ID for a wrong path through the code
* no-critical section
*
* @param[in] id_   ID number (unique within the module) of the assertion
*
* @attention
* This macro must be called inside already established critical section.
* The call to Q_onAssert() happens inside that critical section.
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ERROR_NOCRIT_(id_)  \
    (Q_onAssert(&Q_this_module_[0], (id_)))

/*${QP-FuSa::enabled::Q_ASSERT_ID} .........................................*/
#ifdef QF_CRIT_STAT_
/*! General-purpose assertion with user-specified ID number.
*
* @details
* Evaluates the Boolean expression `expr_` and does nothing else when
* it evaluates to 'true'. However, when `expr_` evaluates to 'false',
* the Q_ASSERT_ID() macro calls the no-return function Q_onAssert().
*
* @param[in] id_   ID number (unique within the module) of the assertion
* @param[in] expr_ Boolean expression to check
*
* @attention
* This macro uses critical section and the evaluation of the expression
* `expr_` as well as calling of Q_onAssert() happens inside the critical
* section.
*
* @attention
* The assertion expression (`expr_`) must be possibly simple, have
* __no side effects__, and quick to evaluate because the evaluation
* happens inside a critical section. Also, the expression must __NOT__
* call any functions that might use critical sections inside (because
* this would cause nesting of critical sections, which might not be
* supported).
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ASSERT_ID(id_, expr_) do { \
    QF_CRIT_STAT_ \
    QF_CRIT_E_(); \
    (expr_) ? ((void)0) : Q_onAssert(&Q_this_module_[0], (id_)); \
    QF_CRIT_X_(); \
} while (false)
#endif /* def QF_CRIT_STAT_ */

/*${QP-FuSa::enabled::Q_ASSERT_ID} .........................................*/
#ifndef QF_CRIT_STAT_
/*! General-purpose assertion with user-specified ID number.
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ASSERT_ID(id_, expr_) Q_ASSERT_NOCRIT_((id_), (expr_))
#endif /* ndef QF_CRIT_STAT_ */

/*${QP-FuSa::enabled::Q_ERROR_ID} ..........................................*/
#ifdef QF_CRIT_STAT_
/*! Assertion with user-specified ID for a wrong path through the code
*
* @details
* Calls the Q_onAssert() callback if ever executed. This assertion
* takes the user-supplied parameter `id_` to identify the location of
* this assertion within the file. This avoids the volatility of using
* line numbers, which change whenever a line of code is added or removed
* upstream from the assertion.
*
* @param[in] id_   ID number (unique within the module) of the assertion
*
* @note
* Does noting when QP Functional Safety System is disabled
* (by defining the macro #QP_NSAFE).
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ERROR_ID(id_) do { \
    QF_CRIT_STAT_ \
    QF_CRIT_E_(); \
    Q_onAssert(&Q_this_module_[0], (id_)); \
    QF_CRIT_X_(); \
} while (false)
#endif /* def QF_CRIT_STAT_ */

/*${QP-FuSa::enabled::Q_ERROR_ID} ..........................................*/
#ifndef QF_CRIT_STAT_
/*! Assertion with user-specified ID for a wrong path through the code
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ERROR_ID(id_) Q_ERROR_NOCRIT_(id_)
#endif /* ndef QF_CRIT_STAT_ */
/*$enddecl${QP-FuSa::enabled} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#else
/*$declare${QP-FuSa::disabled} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${QP-FuSa::disabled::Q_DEFINE_THIS_MODULE} ...............................*/
/*! disabled version of Q_DEFINE_THIS_MODULE() */
#define Q_DEFINE_THIS_MODULE(name_)

/*${QP-FuSa::disabled::Q_ASSERT_NOCRIT_} ...................................*/
/*! disabled version of Q_ASSERT_NOCRIT_() */
#define Q_ASSERT_NOCRIT_(id_, expr_) ((void)0)

/*${QP-FuSa::disabled::Q_ERROR_NOCRIT_} ....................................*/
/*! disabled version of Q_ERROR_NOCRIT_() */
#define Q_ERROR_NOCRIT_(id_) ((void)0)

/*${QP-FuSa::disabled::Q_ASSERT_ID} ........................................*/
/*! disabled version of Q_ASSERT_ID() */
#define Q_ASSERT_ID(id_, expr_) ((void)0)

/*${QP-FuSa::disabled::Q_ERROR_ID} .........................................*/
/*! disabled version of Q_ERROR_ID() */
#define Q_ERROR_ID(id_) ((void)0)
/*$enddecl${QP-FuSa::disabled} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#endif

/*$declare1${QP-FuSa} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/*${QP-FuSa::Q_DEFINE_THIS_FILE} ...........................................*/
/*! Define the file name (with `__FILE__`) for assertions in this file
*
* @details
* Macro to be placed at the top of each C/C++ module to define the
* single instance of the file name string to be used in reporting
* assertions in this module.
*
* @note
* The file name string literal is defined by means of the standard
* preprocessor macro `__FILE__`. However, please note that, depending
* on the compiler, the `__FILE__` macro might contain the whole path name
* to the file, which might be inconvenient to log assertions.
*
* @attention
* This macro should **not** be terminated by a semicolon.
*
* @trace
* - @tr{DVP-QP-PCLP-823}
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_DEFINE_THIS_FILE Q_DEFINE_THIS_MODULE(__FILE__)

/*${QP-FuSa::Q_ASSERT} .....................................................*/
/*! General-purpose assertion (with __LINE__ used as location in the file)
*
* @details
* Equivalent to Q_ASSERT_ID(), except it uses __LINE__ to identify the
* assertion within a file.
*
* @param[in] expr_ Boolean expression to check
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ASSERT(expr_) Q_ASSERT_ID(__LINE__, (expr_))

/*${QP-FuSa::Q_ERROR} ......................................................*/
/*! Assertion for a wrong path through the code
*
* @details
* Calls the Q_onAssert() callback if ever executed.
*
* @note
* This macro identifies the problem location with the line number,
* which might change as the code is modified.
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ERROR() Q_ERROR_ID(__LINE__)

/*${QP-FuSa::Q_REQUIRE_ID} .................................................*/
/*! Assertion for checking **preconditions**.
*
* @details
* Equivalent to Q_ASSERT_ID(), except the name provides a better
* documentation of the intention of this assertion.
*
* @param[in] id_   ID number (unique within the module) of the assertion
* @param[in] expr_ Boolean expression
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_REQUIRE_ID(id_, expr_) Q_ASSERT_ID((id_), (expr_))

/*${QP-FuSa::Q_REQUIRE} ....................................................*/
/*! Assertion for checking preconditions (based on __LINE__).
*
* @details
* Equivalent to Q_ASSERT(), except the name provides a better documentation
* of the intention of this assertion.
*
* @param[in] expr_ Boolean expression
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_REQUIRE(expr_) Q_ASSERT(expr_)

/*${QP-FuSa::Q_REQUIRE_NOCRIT_} ............................................*/
/*! Assertion for checking **preconditions** (no-critical section)
*
* @details
* Equivalent to Q_ASSERT_NOCRIT_(), except the name provides a better
* documentation of the intention of this assertion.
*
* @param[in] id_   ID number (unique within the module) of the assertion
* @param[in] expr_ Boolean expression
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_REQUIRE_NOCRIT_(id_, expr_) Q_ASSERT_NOCRIT_((id_), (expr_))

/*${QP-FuSa::Q_ENSURE_ID} ..................................................*/
/*! Assertion for checking postconditions.
*
* @details
* Equivalent to Q_ASSERT_ID(), except the name provides a better documentation
* of the intention of this assertion.
*
* @param[in] id_   ID number (unique within the module) of the assertion
* @param[in] expr_ Boolean expression
*/
#define Q_ENSURE_ID(id_, expr_) Q_ASSERT_ID((id_), (expr_))

/*${QP-FuSa::Q_ENSURE} .....................................................*/
/*! Assertion for checking postconditions.
*
* @details
* Equivalent to Q_ASSERT(), except the name provides a better documentation
* of the intention of this assertion.
*
* @param[in] expr_ Boolean expression
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ENSURE(expr_) Q_ASSERT(expr_)

/*${QP-FuSa::Q_INVARIANT_ID} ...............................................*/
/*! Assertion for checking invariants.
*
* @details
* Equivalent to Q_ASSERT_ID(), except the name provides a better
* documentation of the intention of this assertion.
*
* @param[in] id_   ID number (unique within the module) of the assertion
* @param[in] expr_ Boolean expression
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_INVARIANT_ID(id_, expr_) Q_ASSERT_ID((id_), (expr_))

/*${QP-FuSa::Q_INVARIANT} ..................................................*/
/*! Assertion for checking invariants.
*
* @details
* Equivalent to Q_ASSERT(), except the name provides a better documentation
* of the intention of this assertion.
*
* @param[in] expr_ Boolean expression
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_INVARIANT(expr_) Q_ASSERT(expr_)

/*${QP-FuSa::Q_ASSERT_STATIC} ..............................................*/
/*! Static (compile-time) assertion.
*
* @details
* This type of assertion deliberately causes a compile-time error when
* the `expr_` Boolean expression evaluates to FALSE. The macro exploits
* the fact that in C/C++ a dimension of an array cannot be negative.
* The compile-time assertion has no runtime side effects.
*
* @param[in] expr_ Compile-time Boolean expression
*
* @note
* The static assertion macro is provided for backwards compatibility with
* older C standards. Newer C11 supports `_Static_assert()`, which should
* be used instead of Q_ASSERT_STATIC().
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_ASSERT_STATIC(expr_) extern char Q_static_assert_[(expr_) ? 1 : -1]

/*${QP-FuSa::Q_NORETURN} ...................................................*/
#ifndef Q_NORETURN
/*! No-return function specifier for the Q_onAssert() callback function.
*
* @details
* If the `Q_NORETURN` macro is undefined, the default definition uses
* the C99 specifier `_Noreturn`.
*
* @note
* The `Q_NORETURN` macro can be defined in the QP port (typically in
* `qep_port.h` or `qep_port.hpp`). If such definition is porvided
* the default won't be used.
*/
#define Q_NORETURN _Noreturn void
#endif /* ndef Q_NORETURN */

/*${QP-FuSa::int_t} ........................................................*/
#ifndef QP_VERSION
/*! typedef for assertions-ids and line numbers in assertions.
*
* @details
* This typedef specifies integer type for exclusive use in assertions.
* Use of this type, rather than plain 'int', is in compliance
* with the MISRA-C:2023 Directive 4.6 (Advisory).
*/
typedef int int_t;
#endif /* ndef QP_VERSION */

/*${QP-FuSa::Q_onAssert} ...................................................*/
/*! Callback function invoked after detecting an error (part of QP
* Functional Safety (FuSa) Subsystem).
*
* @details
* This callback function needs to be defined in the application to perform
* any corrective action after an **unrecoverable error** has been detected.
* The Q_onAssert() function is the last line of defense after the
* system failure and its implementation should be very **carefully**
* designed and **tested** under various fault conditions, including but
* not limited to: stack overflow/corruption, calling Q_onAssert()
* from an ISR or other hardware exception, etc.
*
* @param[in] module name of the file/module in which the assertion failed
*                   (constant, zero-terminated C string)
* @param[in] id     ID of the assertion within the module. This could
*                   be a line number or a user-specified ID-number.
*
* @returns
* This callback function should **not return** (see ::Q_NORETURN),
* as continuation after an unrecoverable error makes no sense.
*
* @attention
* Q_onAssert() must be called within a critical section
* (typically with interrupts **disabled**).
*
* @note
* During debugging, Q_onAssert() is an ideal place to put a breakpoint.
* For deployment, it is **NOT RECOMMENDED** to implement Q_onAssert()
* as an endless loop that ties up the CPU (denial of service).
*
* Called by the following: Q_ASSERT_ID(), Q_ERROR_ID(), Q_REQUIRE_ID(),
* Q_ENSURE_ID(), Q_INVARIANT_ID() as well as:
* Q_ASSERT(), Q_ERROR(), Q_REQUIRE(), Q_ENSURE(), and Q_INVARIANT().
*/
Q_NORETURN Q_onAssert(
    char const * const module,
    int_t const id);

/*${QP-FuSa::Q_DIM} ........................................................*/
#ifndef QP_VERSION
/*! Helper macro to calculate static dimension of a 1-dim `array_`
*
* @param array_ 1-dimensional array
*
* @returns
* The length of the array (number of elements it can hold)
*
* @trace
* - @tr{DVP-QP-MC4-D04_09A} (false-positive)
*/
#define Q_DIM(array_) (sizeof(array_) / sizeof((array_)[0U]))
#endif /* ndef QP_VERSION */
/*$enddecl${QP-FuSa} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

#ifdef __cplusplus
    }
#endif

#endif /* QASSERT_H_ */
